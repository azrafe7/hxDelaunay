// Generated by Haxe 3.4.0
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var DemoJs = function() {
	this.displayHeight = 500;
	this.displayWidth = 500;
	this.setup();
	this.generate();
};
DemoJs.__name__ = true;
DemoJs.main = function() {
	window.document.addEventListener("DOMContentLoaded",function(e) {
		new DemoJs();
	});
};
DemoJs.prototype = {
	setup: function() {
		this.container = window.document.createElement("div");
		this.container.id = "delaunay";
		this.container.className = "container";
		window.document.body.appendChild(this.container);
		this.canvas = window.document.createElement("canvas");
		this.canvas.width = this.displayWidth;
		this.canvas.height = this.displayHeight;
		this.canvas.className = "canvasOne";
		this.canvas.id = "canvasOne";
		this.container.appendChild(this.canvas);
		this.context = this.canvas.getContext("2d",null);
		this.canvas.onclick = $bind(this,this.onClickHandler);
	}
	,onClickHandler: function(e) {
		this.context.clearRect(0,0,this.canvas.width,this.canvas.height);
		this.generate();
		e.preventDefault();
	}
	,generate: function() {
		var rect = new com_nodename_geom_Rectangle(0,0,this.canvas.width,this.canvas.height);
		var points = [];
		var _g = 0;
		while(_g < 25) {
			++_g;
			points.push(new com_nodename_geom_Point(Math.random() * rect.width,Math.random() * rect.height));
		}
		var voronoi = new com_nodename_delaunay_Voronoi(points,null,rect);
		var _g1 = [];
		var _g11 = 0;
		while(_g11 < points.length) {
			var p = points[_g11];
			++_g11;
			_g1.push(voronoi.region(p));
		}
		voronoi.regions();
		var _g2 = 0;
		var _g12 = voronoi.triangles().length;
		while(_g2 < _g12) {
			var sitesArr = voronoi.triangles()[_g2++].sites;
			this.context.beginPath();
			this.context.moveTo(sitesArr[0].coord.x,sitesArr[0].coord.y);
			this.context.lineTo(sitesArr[1].coord.x,sitesArr[1].coord.y);
			this.context.lineTo(sitesArr[2].coord.x,sitesArr[2].coord.y);
			var color = "rgba(" + Std.random(255) + "," + Std.random(255) + "," + Std.random(255) + ", 1)";
			this.context.closePath();
			this.context.fillStyle = color;
			this.context.lineWidth = 0.5;
			this.context.strokeStyle = color;
			this.context.stroke();
			this.context.fill();
		}
	}
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var com_nodename_delaunay_Edge = function() {
	this._edgeIndex = 0;
	this.rightVertex = null;
	this.leftVertex = null;
	this.c = 0;
	this.b = 0;
	this.a = 0;
	this._edgeIndex = com_nodename_delaunay_Edge._nedges++;
	this.init();
};
com_nodename_delaunay_Edge.__name__ = true;
com_nodename_delaunay_Edge.createBisectingEdge = function(site0,site1) {
	var dx = site1.coord.x - site0.coord.x;
	var dy = site1.coord.y - site0.coord.y;
	var c = site0.coord.x * dx + site0.coord.y * dy + (dx * dx + dy * dy) * 0.5;
	var a;
	var b;
	if((dx > 0?dx:-dx) > (dy > 0?dy:-dy)) {
		a = 1.0;
		b = dy / dx;
		c /= dx;
	} else {
		b = 1.0;
		a = dx / dy;
		c /= dy;
	}
	var edge = com_nodename_delaunay_Edge.create();
	edge.leftSite = site0;
	edge.rightSite = site1;
	site0.edges.push(edge);
	site1.edges.push(edge);
	edge.leftVertex = null;
	edge.rightVertex = null;
	edge.a = a;
	edge.b = b;
	edge.c = c;
	return edge;
};
com_nodename_delaunay_Edge.create = function() {
	var edge;
	if(com_nodename_delaunay_Edge._pool.length > 0) {
		edge = com_nodename_delaunay_Edge._pool.pop();
		edge.init();
	} else {
		edge = new com_nodename_delaunay_Edge();
	}
	return edge;
};
com_nodename_delaunay_Edge.prototype = {
	setVertex: function(leftRight,v) {
		if(leftRight == com_nodename_delaunay_LR.LEFT) {
			this.leftVertex = v;
		} else {
			this.rightVertex = v;
		}
	}
	,clippedEnds: function(or) {
		if(or == com_nodename_delaunay_LR.LEFT) {
			return this.__leftPoint;
		} else {
			return this.__rightPoint;
		}
	}
	,setClippedEnds: function(or,p) {
		if(or == com_nodename_delaunay_LR.LEFT) {
			this.__leftPoint = p;
		} else {
			this.__rightPoint = p;
		}
	}
	,init: function() {
		this.__leftPoint = null;
		this.__rightPoint = null;
		this.leftSite = null;
		this.rightSite = null;
	}
	,clipVertices: function(bounds) {
		var xmin = bounds.x;
		var ymin = bounds.y;
		var xmax = bounds.x + bounds.width;
		var ymax = bounds.y + bounds.height;
		var vertex0;
		var vertex1;
		var x0;
		var x1;
		var y0;
		var y1;
		if(this.a == 1.0 && this.b >= 0.0) {
			vertex0 = this.rightVertex;
			vertex1 = this.leftVertex;
		} else {
			vertex0 = this.leftVertex;
			vertex1 = this.rightVertex;
		}
		if(this.a == 1.0) {
			y0 = ymin;
			if(vertex0 != null && vertex0.coord.y > ymin) {
				y0 = vertex0.coord.y;
			}
			if(y0 > ymax) {
				return;
			}
			x0 = this.c - this.b * y0;
			y1 = ymax;
			if(vertex1 != null && vertex1.coord.y < ymax) {
				y1 = vertex1.coord.y;
			}
			if(y1 < ymin) {
				return;
			}
			x1 = this.c - this.b * y1;
			if(x0 > xmax && x1 > xmax || x0 < xmin && x1 < xmin) {
				return;
			}
			if(x0 > xmax) {
				x0 = xmax;
				y0 = (this.c - xmax) / this.b;
			} else if(x0 < xmin) {
				x0 = xmin;
				y0 = (this.c - xmin) / this.b;
			}
			if(x1 > xmax) {
				x1 = xmax;
				y1 = (this.c - xmax) / this.b;
			} else if(x1 < xmin) {
				x1 = xmin;
				y1 = (this.c - xmin) / this.b;
			}
		} else {
			x0 = xmin;
			if(vertex0 != null && vertex0.coord.x > xmin) {
				x0 = vertex0.coord.x;
			}
			if(x0 > xmax) {
				return;
			}
			y0 = this.c - this.a * x0;
			x1 = xmax;
			if(vertex1 != null && vertex1.coord.x < xmax) {
				x1 = vertex1.coord.x;
			}
			if(x1 < xmin) {
				return;
			}
			y1 = this.c - this.a * x1;
			if(y0 > ymax && y1 > ymax || y0 < ymin && y1 < ymin) {
				return;
			}
			if(y0 > ymax) {
				y0 = ymax;
				x0 = (this.c - ymax) / this.a;
			} else if(y0 < ymin) {
				y0 = ymin;
				x0 = (this.c - ymin) / this.a;
			}
			if(y1 > ymax) {
				y1 = ymax;
				x1 = (this.c - ymax) / this.a;
			} else if(y1 < ymin) {
				y1 = ymin;
				x1 = (this.c - ymin) / this.a;
			}
		}
		if(vertex0 == this.leftVertex) {
			this.setClippedEnds(com_nodename_delaunay_LR.LEFT,new com_nodename_geom_Point(x0,y0));
			this.setClippedEnds(com_nodename_delaunay_LR.RIGHT,new com_nodename_geom_Point(x1,y1));
		} else {
			this.setClippedEnds(com_nodename_delaunay_LR.RIGHT,new com_nodename_geom_Point(x0,y0));
			this.setClippedEnds(com_nodename_delaunay_LR.LEFT,new com_nodename_geom_Point(x1,y1));
		}
	}
};
var com_nodename_delaunay_IDisposable = function() { };
com_nodename_delaunay_IDisposable.__name__ = true;
var com_nodename_delaunay_EdgeList = function(xmin,deltax,sqrt_nsites) {
	this._xmin = 0;
	this._deltax = 0;
	this._xmin = xmin;
	this._deltax = deltax;
	this._hashsize = 2 * sqrt_nsites;
	this._hash = [];
	this._hash[this._hashsize - 1] = null;
	this.leftEnd = com_nodename_delaunay_Halfedge.createDummy();
	this.rightEnd = com_nodename_delaunay_Halfedge.createDummy();
	this.leftEnd.edgeListLeftNeighbor = null;
	this.leftEnd.edgeListRightNeighbor = this.rightEnd;
	this.rightEnd.edgeListLeftNeighbor = this.leftEnd;
	this.rightEnd.edgeListRightNeighbor = null;
	this._hash[0] = this.leftEnd;
	this._hash[this._hashsize - 1] = this.rightEnd;
};
com_nodename_delaunay_EdgeList.__name__ = true;
com_nodename_delaunay_EdgeList.__interfaces__ = [com_nodename_delaunay_IDisposable];
com_nodename_delaunay_EdgeList.prototype = {
	dispose: function() {
		var halfEdge = this.leftEnd;
		var prevHe;
		while(halfEdge != this.rightEnd) {
			prevHe = halfEdge;
			halfEdge = halfEdge.edgeListRightNeighbor;
			prevHe.dispose();
		}
		this.leftEnd = null;
		this.rightEnd.dispose();
		this.rightEnd = null;
		var _g1 = 0;
		var _g = this._hashsize;
		while(_g1 < _g) this._hash[_g1++] = null;
		this._hash = null;
	}
	,insert: function(lb,newHalfedge) {
		newHalfedge.edgeListLeftNeighbor = lb;
		newHalfedge.edgeListRightNeighbor = lb.edgeListRightNeighbor;
		lb.edgeListRightNeighbor.edgeListLeftNeighbor = newHalfedge;
		lb.edgeListRightNeighbor = newHalfedge;
	}
	,remove: function(halfEdge) {
		halfEdge.edgeListLeftNeighbor.edgeListRightNeighbor = halfEdge.edgeListRightNeighbor;
		halfEdge.edgeListRightNeighbor.edgeListLeftNeighbor = halfEdge.edgeListLeftNeighbor;
		halfEdge.edge = com_nodename_delaunay_Edge.DELETED;
		halfEdge.edgeListLeftNeighbor = halfEdge.edgeListRightNeighbor = null;
	}
	,edgeListLeftNeighbor: function(p) {
		var bucket = (p.x - this._xmin) / this._deltax * this._hashsize | 0;
		if(bucket < 0) {
			bucket = 0;
		}
		if(bucket >= this._hashsize) {
			bucket = this._hashsize - 1;
		}
		var halfEdge = this.getHash(bucket);
		if(halfEdge == null) {
			var i = 1;
			while(true) {
				halfEdge = this.getHash(bucket - i);
				if(halfEdge != null) {
					break;
				}
				halfEdge = this.getHash(bucket + i);
				if(halfEdge != null) {
					break;
				}
				++i;
			}
		}
		if(halfEdge == this.leftEnd || halfEdge != this.rightEnd && halfEdge.isLeftOf(p)) {
			while(true) {
				halfEdge = halfEdge.edgeListRightNeighbor;
				if(!(halfEdge != this.rightEnd && halfEdge.isLeftOf(p))) {
					break;
				}
			}
			halfEdge = halfEdge.edgeListLeftNeighbor;
		} else {
			while(true) {
				halfEdge = halfEdge.edgeListLeftNeighbor;
				if(!(halfEdge != this.leftEnd && !halfEdge.isLeftOf(p))) {
					break;
				}
			}
		}
		if(bucket > 0 && bucket < this._hashsize - 1) {
			this._hash[bucket] = halfEdge;
		}
		return halfEdge;
	}
	,getHash: function(b) {
		var halfEdge = null;
		if(b >= 0 && b < this._hashsize) {
			halfEdge = this._hash[b];
			if(halfEdge != null && halfEdge.edge == com_nodename_delaunay_Edge.DELETED) {
				this._hash[b] = null;
				halfEdge = null;
			}
		}
		return halfEdge;
	}
};
var com_nodename_delaunay_EdgeReorderer = function(origEdges,leftCoord,rightCoord) {
	this.edges = [];
	this.edgeOrientations = [];
	if(origEdges.length > 0) {
		this.edges = this.reorderEdges(origEdges,leftCoord,rightCoord);
	}
};
com_nodename_delaunay_EdgeReorderer.__name__ = true;
com_nodename_delaunay_EdgeReorderer.edgeToLeftVertex = function(ed) {
	return ed.leftVertex;
};
com_nodename_delaunay_EdgeReorderer.edgeToRightVertex = function(ed) {
	return ed.rightVertex;
};
com_nodename_delaunay_EdgeReorderer.prototype = {
	dispose: function() {
		this.edges = null;
		this.edgeOrientations = null;
	}
	,reorderEdges: function(origEdges,leftCoord,rightCoord) {
		var n = origEdges.length;
		var edge;
		var done = [];
		done[n - 1] = false;
		var nDone = 0;
		var _g = 0;
		while(_g < done.length) ++_g;
		var newEdges = [];
		edge = origEdges[0];
		newEdges.push(edge);
		this.edgeOrientations.push(com_nodename_delaunay_LR.LEFT);
		var firstPoint = leftCoord(edge);
		var lastPoint = rightCoord(edge);
		if(firstPoint == com_nodename_delaunay_Vertex.VERTEX_AT_INFINITY || lastPoint == com_nodename_delaunay_Vertex.VERTEX_AT_INFINITY) {
			return [];
		}
		done[0] = true;
		nDone = 1;
		while(nDone < n) {
			var _g1 = 1;
			while(_g1 < n) {
				var i = _g1++;
				if(done[i]) {
					continue;
				}
				edge = origEdges[i];
				var leftPoint = leftCoord(edge);
				var rightPoint = rightCoord(edge);
				if(leftPoint == com_nodename_delaunay_Vertex.VERTEX_AT_INFINITY || rightPoint == com_nodename_delaunay_Vertex.VERTEX_AT_INFINITY) {
					return [];
				}
				if(leftPoint == lastPoint) {
					lastPoint = rightPoint;
					this.edgeOrientations.push(com_nodename_delaunay_LR.LEFT);
					newEdges.push(edge);
					done[i] = true;
				} else if(rightPoint == firstPoint) {
					firstPoint = leftPoint;
					this.edgeOrientations.unshift(com_nodename_delaunay_LR.LEFT);
					newEdges.unshift(edge);
					done[i] = true;
				} else if(leftPoint == firstPoint) {
					firstPoint = rightPoint;
					this.edgeOrientations.unshift(com_nodename_delaunay_LR.RIGHT);
					newEdges.unshift(edge);
					done[i] = true;
				} else if(rightPoint == lastPoint) {
					lastPoint = leftPoint;
					this.edgeOrientations.push(com_nodename_delaunay_LR.RIGHT);
					newEdges.push(edge);
					done[i] = true;
				}
				if(done[i]) {
					++nDone;
				}
			}
		}
		return newEdges;
	}
};
var com_nodename_delaunay_Halfedge = function(edge,lr) {
	this.ystar = 0;
	this.init(edge,lr);
};
com_nodename_delaunay_Halfedge.__name__ = true;
com_nodename_delaunay_Halfedge.create = function(edge,lr) {
	if(com_nodename_delaunay_Halfedge._pool.length > 0) {
		return com_nodename_delaunay_Halfedge._pool.pop().init(edge,lr);
	} else {
		return new com_nodename_delaunay_Halfedge(edge,lr);
	}
};
com_nodename_delaunay_Halfedge.createDummy = function() {
	return com_nodename_delaunay_Halfedge.create(null,null);
};
com_nodename_delaunay_Halfedge.prototype = {
	init: function(edge,lr) {
		this.edge = edge;
		this.leftRight = lr;
		this.nextInPriorityQueue = null;
		this.vertex = null;
		return this;
	}
	,dispose: function() {
		if(this.edgeListLeftNeighbor != null || this.edgeListRightNeighbor != null) {
			return;
		}
		if(this.nextInPriorityQueue != null) {
			return;
		}
		this.edge = null;
		this.leftRight = null;
		this.vertex = null;
		com_nodename_delaunay_Halfedge._pool.push(this);
	}
	,reallyDispose: function() {
		this.edgeListLeftNeighbor = null;
		this.edgeListRightNeighbor = null;
		this.nextInPriorityQueue = null;
		this.edge = null;
		this.leftRight = null;
		this.vertex = null;
		com_nodename_delaunay_Halfedge._pool.push(this);
	}
	,isLeftOf: function(p) {
		var above;
		var topSite = this.edge.rightSite;
		var rightOfSite = p.x > topSite.coord.x;
		if(rightOfSite && this.leftRight == com_nodename_delaunay_LR.LEFT) {
			return true;
		}
		if(!rightOfSite && this.leftRight == com_nodename_delaunay_LR.RIGHT) {
			return false;
		}
		if(this.edge.a == 1.0) {
			var dyp = p.y - topSite.coord.y;
			var dxp = p.x - topSite.coord.x;
			var fast = false;
			if(!rightOfSite && this.edge.b < 0.0 || rightOfSite && this.edge.b >= 0.0) {
				above = dyp >= this.edge.b * dxp;
				fast = above;
			} else {
				above = p.x + p.y * this.edge.b > this.edge.c;
				if(this.edge.b < 0.0) {
					above = !above;
				}
				fast = !above;
			}
			if(!fast) {
				var dxs = topSite.coord.x - this.edge.leftSite.coord.x;
				above = this.edge.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1.0 + 2.0 * dxp / dxs + this.edge.b * this.edge.b);
				if(this.edge.b < 0.0) {
					above = !above;
				}
			}
		} else {
			var yl = this.edge.c - this.edge.a * p.x;
			var t1 = p.y - yl;
			var t2 = p.x - topSite.coord.x;
			var t3 = yl - topSite.coord.y;
			above = t1 * t1 > t2 * t2 + t3 * t3;
		}
		if(this.leftRight == com_nodename_delaunay_LR.LEFT) {
			return above;
		} else {
			return !above;
		}
	}
};
var com_nodename_delaunay_HalfedgePriorityQueue = function(ymin,deltay,sqrt_nsites) {
	this._deltay = 0;
	this._ymin = 0;
	this._ymin = ymin;
	this._deltay = deltay;
	this._hashsize = 4 * sqrt_nsites;
	this.initialize();
};
com_nodename_delaunay_HalfedgePriorityQueue.__name__ = true;
com_nodename_delaunay_HalfedgePriorityQueue.prototype = {
	dispose: function() {
		var _g1 = 0;
		var _g = this._hashsize;
		while(_g1 < _g) {
			var i = _g1++;
			this._hash[i].dispose();
			this._hash[i] = null;
		}
		this._hash = null;
	}
	,initialize: function() {
		this._count = 0;
		this._minBucket = 0;
		this._hash = [];
		this._hash[this._hashsize - 1] = null;
		var _g1 = 0;
		var _g = this._hashsize;
		while(_g1 < _g) {
			var i = _g1++;
			this._hash[i] = com_nodename_delaunay_Halfedge.createDummy();
			this._hash[i].nextInPriorityQueue = null;
		}
	}
	,insert: function(halfEdge) {
		var previous;
		var next;
		var insertionBucket = this.bucket(halfEdge);
		if(insertionBucket < this._minBucket) {
			this._minBucket = insertionBucket;
		}
		previous = this._hash[insertionBucket];
		while(true) {
			var tmp;
			next = previous.nextInPriorityQueue;
			if(next != null) {
				if(!(halfEdge.ystar > next.ystar)) {
					if(halfEdge.ystar == next.ystar) {
						tmp = halfEdge.vertex.coord.x > next.vertex.coord.x;
					} else {
						tmp = false;
					}
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			previous = next;
		}
		halfEdge.nextInPriorityQueue = previous.nextInPriorityQueue;
		previous.nextInPriorityQueue = halfEdge;
		++this._count;
	}
	,remove: function(halfEdge) {
		if(halfEdge.vertex != null) {
			var previous = this._hash[this.bucket(halfEdge)];
			while(previous.nextInPriorityQueue != halfEdge) previous = previous.nextInPriorityQueue;
			previous.nextInPriorityQueue = halfEdge.nextInPriorityQueue;
			this._count--;
			halfEdge.vertex = null;
			halfEdge.nextInPriorityQueue = null;
			halfEdge.dispose();
		}
	}
	,bucket: function(halfEdge) {
		var theBucket = (halfEdge.ystar - this._ymin) / this._deltay * this._hashsize | 0;
		if(theBucket < 0) {
			theBucket = 0;
		}
		if(theBucket >= this._hashsize) {
			theBucket = this._hashsize - 1;
		}
		return theBucket;
	}
	,isEmpty: function(bucket) {
		return this._hash[bucket].nextInPriorityQueue == null;
	}
	,adjustMinBucket: function() {
		while(this._minBucket < this._hashsize - 1 && this.isEmpty(this._minBucket)) ++this._minBucket;
	}
	,empty: function() {
		return this._count == 0;
	}
	,min: function() {
		this.adjustMinBucket();
		var answer = this._hash[this._minBucket].nextInPriorityQueue;
		return new com_nodename_geom_Point(answer.vertex.coord.x,answer.ystar);
	}
	,extractMin: function() {
		var answer = this._hash[this._minBucket].nextInPriorityQueue;
		this._hash[this._minBucket].nextInPriorityQueue = answer.nextInPriorityQueue;
		this._count--;
		answer.nextInPriorityQueue = null;
		return answer;
	}
};
var com_nodename_delaunay_ICoord = function() { };
com_nodename_delaunay_ICoord.__name__ = true;
var com_nodename_delaunay_LR = function(name) {
	this._name = name;
};
com_nodename_delaunay_LR.__name__ = true;
com_nodename_delaunay_LR.other = function(leftRight) {
	if(leftRight == com_nodename_delaunay_LR.LEFT) {
		return com_nodename_delaunay_LR.RIGHT;
	} else {
		return com_nodename_delaunay_LR.LEFT;
	}
};
var com_nodename_delaunay_Site = function(p,index,weight,color) {
	this.weight = 0;
	this.init(p,index,weight,color);
};
com_nodename_delaunay_Site.__name__ = true;
com_nodename_delaunay_Site.__interfaces__ = [com_nodename_delaunay_ICoord];
com_nodename_delaunay_Site.create = function(p,index,weight,color) {
	if(com_nodename_delaunay_Site._pool.length > 0) {
		return com_nodename_delaunay_Site._pool.pop().init(p,index,weight,color);
	} else {
		return new com_nodename_delaunay_Site(p,index,weight,color);
	}
};
com_nodename_delaunay_Site.compare = function(s1,s2) {
	var returnValue = com_nodename_delaunay_Voronoi.compareByYThenX(s1,s2);
	var tempIndex;
	if(returnValue == -1) {
		if(s1._siteIndex > s2._siteIndex) {
			tempIndex = s1._siteIndex;
			s1._siteIndex = s2._siteIndex;
			s2._siteIndex = tempIndex;
		}
	} else if(returnValue == 1) {
		if(s2._siteIndex > s1._siteIndex) {
			tempIndex = s2._siteIndex;
			s2._siteIndex = s1._siteIndex;
			s1._siteIndex = tempIndex;
		}
	}
	return returnValue;
};
com_nodename_delaunay_Site.closeEnough = function(p0,p1) {
	return Math.sqrt((p0.x - p1.x) * (p0.x - p1.x) + (p0.y - p1.y) * (p0.y - p1.y)) < com_nodename_delaunay_Site.EPSILON;
};
com_nodename_delaunay_Site.prototype = {
	get_coord: function() {
		return this.coord;
	}
	,init: function(p,index,weight,color) {
		this.coord = p;
		this._siteIndex = index;
		this.weight = weight;
		this.color = color;
		this.edges = [];
		this._region = null;
		return this;
	}
	,region: function(clippingBounds) {
		if(this.edges == null || this.edges.length == 0) {
			return [];
		}
		if(this._edgeOrientations == null) {
			this.reorderEdges();
			this._region = this.clipToBounds(clippingBounds);
			if(new com_nodename_geom_Polygon(this._region).winding() == com_nodename_geom_Winding.CLOCKWISE) {
				this._region.reverse();
			}
		}
		return this._region;
	}
	,reorderEdges: function() {
		var reorderer = new com_nodename_delaunay_EdgeReorderer(this.edges,com_nodename_delaunay_EdgeReorderer.edgeToLeftVertex,com_nodename_delaunay_EdgeReorderer.edgeToRightVertex);
		this.edges = reorderer.edges;
		this._edgeOrientations = reorderer.edgeOrientations;
		reorderer.dispose();
	}
	,clipToBounds: function(bounds) {
		var points = [];
		var n = this.edges.length;
		var i = 0;
		var edge;
		while(true) {
			var tmp;
			if(i < n) {
				var _this = this.edges[i];
				tmp = (_this.__leftPoint != null && _this.__rightPoint != null) == false;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			++i;
		}
		if(i == n) {
			return [];
		}
		edge = this.edges[i];
		var orientation = this._edgeOrientations[i];
		points.push(edge.clippedEnds(orientation));
		points.push(edge.clippedEnds(com_nodename_delaunay_LR.other(orientation)));
		var _g1 = i + 1;
		while(_g1 < n) {
			var j = _g1++;
			edge = this.edges[j];
			if((edge.__leftPoint != null && edge.__rightPoint != null) == false) {
				continue;
			}
			this.connect(points,j,bounds);
		}
		this.connect(points,i,bounds,true);
		return points;
	}
	,connect: function(points,j,bounds,closingUp) {
		if(closingUp == null) {
			closingUp = false;
		}
		var rightPoint = points[points.length - 1];
		var newEdge = this.edges[j];
		var newOrientation = this._edgeOrientations[j];
		var newPoint = newEdge.clippedEnds(newOrientation);
		if(!com_nodename_delaunay_Site.closeEnough(rightPoint,newPoint)) {
			if(rightPoint.x != newPoint.x && rightPoint.y != newPoint.y) {
				var rightCheck = com_nodename_delaunay_BoundsCheck.check(rightPoint,bounds);
				var newCheck = com_nodename_delaunay_BoundsCheck.check(newPoint,bounds);
				var px;
				var py;
				if((rightCheck & com_nodename_delaunay_BoundsCheck.RIGHT) != 0) {
					px = bounds.x + bounds.width;
					if((newCheck & com_nodename_delaunay_BoundsCheck.BOTTOM) != 0) {
						py = bounds.y + bounds.height;
						points.push(new com_nodename_geom_Point(px,py));
					} else if((newCheck & com_nodename_delaunay_BoundsCheck.TOP) != 0) {
						py = bounds.y;
						points.push(new com_nodename_geom_Point(px,py));
					} else if((newCheck & com_nodename_delaunay_BoundsCheck.LEFT) != 0) {
						if(rightPoint.y - bounds.y + newPoint.y - bounds.y < bounds.height) {
							py = bounds.y;
						} else {
							py = bounds.y + bounds.height;
						}
						points.push(new com_nodename_geom_Point(px,py));
						points.push(new com_nodename_geom_Point(bounds.x,py));
					}
				} else if((rightCheck & com_nodename_delaunay_BoundsCheck.LEFT) != 0) {
					px = bounds.x;
					if((newCheck & com_nodename_delaunay_BoundsCheck.BOTTOM) != 0) {
						py = bounds.y + bounds.height;
						points.push(new com_nodename_geom_Point(px,py));
					} else if((newCheck & com_nodename_delaunay_BoundsCheck.TOP) != 0) {
						py = bounds.y;
						points.push(new com_nodename_geom_Point(px,py));
					} else if((newCheck & com_nodename_delaunay_BoundsCheck.RIGHT) != 0) {
						if(rightPoint.y - bounds.y + newPoint.y - bounds.y < bounds.height) {
							py = bounds.y;
						} else {
							py = bounds.y + bounds.height;
						}
						points.push(new com_nodename_geom_Point(px,py));
						points.push(new com_nodename_geom_Point(bounds.x + bounds.width,py));
					}
				} else if((rightCheck & com_nodename_delaunay_BoundsCheck.TOP) != 0) {
					py = bounds.y;
					if((newCheck & com_nodename_delaunay_BoundsCheck.RIGHT) != 0) {
						px = bounds.x + bounds.width;
						points.push(new com_nodename_geom_Point(px,py));
					} else if((newCheck & com_nodename_delaunay_BoundsCheck.LEFT) != 0) {
						px = bounds.x;
						points.push(new com_nodename_geom_Point(px,py));
					} else if((newCheck & com_nodename_delaunay_BoundsCheck.BOTTOM) != 0) {
						if(rightPoint.x - bounds.x + newPoint.x - bounds.x < bounds.width) {
							px = bounds.x;
						} else {
							px = bounds.x + bounds.width;
						}
						points.push(new com_nodename_geom_Point(px,py));
						points.push(new com_nodename_geom_Point(px,bounds.y + bounds.height));
					}
				} else if((rightCheck & com_nodename_delaunay_BoundsCheck.BOTTOM) != 0) {
					py = bounds.y + bounds.height;
					if((newCheck & com_nodename_delaunay_BoundsCheck.RIGHT) != 0) {
						px = bounds.x + bounds.width;
						points.push(new com_nodename_geom_Point(px,py));
					} else if((newCheck & com_nodename_delaunay_BoundsCheck.LEFT) != 0) {
						px = bounds.x;
						points.push(new com_nodename_geom_Point(px,py));
					} else if((newCheck & com_nodename_delaunay_BoundsCheck.TOP) != 0) {
						if(rightPoint.x - bounds.x + newPoint.x - bounds.x < bounds.width) {
							px = bounds.x;
						} else {
							px = bounds.x + bounds.width;
						}
						points.push(new com_nodename_geom_Point(px,py));
						points.push(new com_nodename_geom_Point(px,bounds.y));
					}
				}
			}
			if(closingUp) {
				return;
			}
			points.push(newPoint);
		}
		var newRightPoint = newEdge.clippedEnds(com_nodename_delaunay_LR.other(newOrientation));
		if(!com_nodename_delaunay_Site.closeEnough(points[0],newRightPoint)) {
			points.push(newRightPoint);
		}
	}
	,dist: function(p) {
		return Math.sqrt((p.get_coord().x - this.coord.x) * (p.get_coord().x - this.coord.x) + (p.get_coord().y - this.coord.y) * (p.get_coord().y - this.coord.y));
	}
};
var com_nodename_delaunay_BoundsCheck = function() { };
com_nodename_delaunay_BoundsCheck.__name__ = true;
com_nodename_delaunay_BoundsCheck.check = function(point,bounds) {
	var value = 0;
	if(point.x == bounds.x) {
		value = 0 | com_nodename_delaunay_BoundsCheck.LEFT;
	} else if(point.x == bounds.x + bounds.width) {
		value = 0 | com_nodename_delaunay_BoundsCheck.RIGHT;
	}
	if(point.y == bounds.y) {
		value |= com_nodename_delaunay_BoundsCheck.TOP;
	} else if(point.y == bounds.y + bounds.height) {
		value |= com_nodename_delaunay_BoundsCheck.BOTTOM;
	}
	return value;
};
var com_nodename_delaunay_SiteList = function() {
	this._sites = [];
	this._sorted = false;
};
com_nodename_delaunay_SiteList.__name__ = true;
com_nodename_delaunay_SiteList.__interfaces__ = [com_nodename_delaunay_IDisposable];
com_nodename_delaunay_SiteList.prototype = {
	push: function(site) {
		this._sorted = false;
		return this._sites.push(site);
	}
	,next: function() {
		if(this._sorted == false) {
			throw new js__$Boot_HaxeError("SiteList::next():  sites have not been sorted");
		}
		if(this._currentIndex < this._sites.length) {
			return this._sites[this._currentIndex++];
		} else {
			return null;
		}
	}
	,getSitesBounds: function() {
		if(this._sorted == false) {
			this._sites.sort(com_nodename_delaunay_Site.compare);
			this._currentIndex = 0;
			this._sorted = true;
		}
		var xmin;
		var xmax;
		var ymin;
		var ymax;
		if(this._sites.length == 0) {
			return new com_nodename_geom_Rectangle(0,0,0,0);
		}
		xmin = Infinity;
		xmax = -Infinity;
		var _g = 0;
		var _g1 = this._sites;
		while(_g < _g1.length) {
			var site = _g1[_g];
			++_g;
			if(site.coord.x < xmin) {
				xmin = site.coord.x;
			}
			if(site.coord.x > xmax) {
				xmax = site.coord.x;
			}
		}
		ymin = this._sites[0].coord.y;
		ymax = this._sites[this._sites.length - 1].coord.y;
		return new com_nodename_geom_Rectangle(xmin,ymin,xmax - xmin,ymax - ymin);
	}
	,regions: function(plotBounds) {
		var regions = [];
		var _g = 0;
		var _g1 = this._sites;
		while(_g < _g1.length) {
			var site = _g1[_g];
			++_g;
			regions.push(site.region(plotBounds));
		}
		return regions;
	}
};
var com_nodename_delaunay_Triangle = function(a,b,c) {
	this.sites = [a,b,c];
};
com_nodename_delaunay_Triangle.__name__ = true;
var com_nodename_delaunay_Vertex = function(x,y) {
	this.init(x,y);
};
com_nodename_delaunay_Vertex.__name__ = true;
com_nodename_delaunay_Vertex.__interfaces__ = [com_nodename_delaunay_ICoord];
com_nodename_delaunay_Vertex.create = function(x,y) {
	if(isNaN(x) || isNaN(y)) {
		return com_nodename_delaunay_Vertex.VERTEX_AT_INFINITY;
	}
	if(com_nodename_delaunay_Vertex._pool.length > 0) {
		return com_nodename_delaunay_Vertex._pool.pop().init(x,y);
	} else {
		return new com_nodename_delaunay_Vertex(x,y);
	}
};
com_nodename_delaunay_Vertex.intersect = function(halfedge0,halfedge1) {
	var halfedge;
	var determinant;
	var intersectionX;
	var intersectionY;
	var rightOfSite;
	var edge0 = halfedge0.edge;
	var edge1 = halfedge1.edge;
	if(edge0 == null || edge1 == null) {
		return null;
	}
	if(edge0.rightSite == edge1.rightSite) {
		return null;
	}
	determinant = edge0.a * edge1.b - edge0.b * edge1.a;
	if(-1.0e-10 < determinant && determinant < 1.0e-10) {
		return null;
	}
	var oneOverDet = 1 / determinant;
	intersectionX = (edge0.c * edge1.b - edge1.c * edge0.b) * oneOverDet;
	intersectionY = (edge1.c * edge0.a - edge0.c * edge1.a) * oneOverDet;
	var edge;
	var s1 = edge0.rightSite;
	var s2 = edge1.rightSite;
	if(s1.coord.y < s2.coord.y || s1.coord.y == s2.coord.y && s1.coord.x < s2.coord.x) {
		halfedge = halfedge0;
		edge = edge0;
	} else {
		halfedge = halfedge1;
		edge = edge1;
	}
	rightOfSite = intersectionX >= edge.rightSite.coord.x;
	if(rightOfSite && halfedge.leftRight == com_nodename_delaunay_LR.LEFT || !rightOfSite && halfedge.leftRight == com_nodename_delaunay_LR.RIGHT) {
		return null;
	}
	return com_nodename_delaunay_Vertex.create(intersectionX,intersectionY);
};
com_nodename_delaunay_Vertex.prototype = {
	get_coord: function() {
		return this.coord;
	}
	,init: function(x,y) {
		this.coord = new com_nodename_geom_Point(x,y);
		return this;
	}
	,dispose: function() {
		this.coord = null;
		com_nodename_delaunay_Vertex._pool.push(this);
	}
};
var com_nodename_delaunay_Voronoi = function(points,colors,plotBounds) {
	this._sites = new com_nodename_delaunay_SiteList();
	this._sitesIndexedByLocation = new haxe_ds_ObjectMap();
	this.addSites(points,colors);
	this._plotBounds = plotBounds;
	this._triangles = [];
	this._edges = [];
	this.fortunesAlgorithm();
};
com_nodename_delaunay_Voronoi.__name__ = true;
com_nodename_delaunay_Voronoi.compareByYThenX = function(s1,s2) {
	if(s1.coord.y < s2.coord.y) {
		return -1;
	}
	if(s1.coord.y > s2.coord.y) {
		return 1;
	}
	if(s1.coord.x < s2.coord.x) {
		return -1;
	}
	if(s1.coord.x > s2.coord.x) {
		return 1;
	}
	return 0;
};
com_nodename_delaunay_Voronoi.prototype = {
	addSites: function(points,colors) {
		var length = points.length;
		var _g1 = 0;
		while(_g1 < length) {
			var i = _g1++;
			this.addSite(points[i],colors != null?colors[i]:0,i);
		}
	}
	,addSite: function(p,color,index) {
		var site = com_nodename_delaunay_Site.create(p,index,Math.random() * 100,color);
		this._sites.push(site);
		this._sitesIndexedByLocation.set(p,site);
	}
	,region: function(p) {
		var site = this._sitesIndexedByLocation.h[p.__id__];
		if(site == null) {
			return [];
		}
		return site.region(this._plotBounds);
	}
	,regions: function() {
		return this._sites.regions(this._plotBounds);
	}
	,triangles: function() {
		return this._triangles;
	}
	,fortunesAlgorithm: function() {
		var newSite;
		var newintstar = null;
		var dataBounds = this._sites.getSitesBounds();
		var sqrt_nsites = Math.sqrt(this._sites._sites.length + 4) | 0;
		var heap = new com_nodename_delaunay_HalfedgePriorityQueue(dataBounds.y,dataBounds.height,sqrt_nsites);
		var edgeList = new com_nodename_delaunay_EdgeList(dataBounds.x,dataBounds.width,sqrt_nsites);
		var halfEdges = [];
		var vertices = [];
		var bottomMostSite = this._sites.next();
		var leftRegion = function(he) {
			var edge = he.edge;
			if(edge == null) {
				return bottomMostSite;
			}
			if(he.leftRight == com_nodename_delaunay_LR.LEFT) {
				return edge.leftSite;
			} else {
				return edge.rightSite;
			}
		};
		var rightRegion = function(he1) {
			var edge1 = he1.edge;
			if(edge1 == null) {
				return bottomMostSite;
			}
			if(com_nodename_delaunay_LR.other(he1.leftRight) == com_nodename_delaunay_LR.LEFT) {
				return edge1.leftSite;
			} else {
				return edge1.rightSite;
			}
		};
		newSite = this._sites.next();
		while(true) {
			if(heap.empty() == false) {
				newintstar = heap.min();
			}
			if(newSite != null && (heap.empty() || (newSite.coord.y < newintstar.y || newSite.coord.y == newintstar.y && newSite.coord.x < newintstar.x))) {
				var lbnd = edgeList.edgeListLeftNeighbor(newSite.coord);
				var rbnd = lbnd.edgeListRightNeighbor;
				var edge2 = com_nodename_delaunay_Edge.createBisectingEdge(rightRegion(lbnd),newSite);
				this._edges.push(edge2);
				var bisector = com_nodename_delaunay_Halfedge.create(edge2,com_nodename_delaunay_LR.LEFT);
				halfEdges.push(bisector);
				edgeList.insert(lbnd,bisector);
				var vertex = com_nodename_delaunay_Vertex.intersect(lbnd,bisector);
				if(vertex != null) {
					heap.remove(lbnd);
					vertices.push(vertex);
					lbnd.vertex = vertex;
					lbnd.ystar = vertex.coord.y + newSite.dist(vertex);
					heap.insert(lbnd);
				}
				lbnd = bisector;
				bisector = com_nodename_delaunay_Halfedge.create(edge2,com_nodename_delaunay_LR.RIGHT);
				halfEdges.push(bisector);
				edgeList.insert(lbnd,bisector);
				var vertex1 = com_nodename_delaunay_Vertex.intersect(bisector,rbnd);
				if(vertex1 != null) {
					vertices.push(vertex1);
					bisector.vertex = vertex1;
					bisector.ystar = vertex1.coord.y + newSite.dist(vertex1);
					heap.insert(bisector);
				}
				newSite = this._sites.next();
			} else if(heap.empty() == false) {
				var lbnd1 = heap.extractMin();
				var llbnd = lbnd1.edgeListLeftNeighbor;
				var rbnd1 = lbnd1.edgeListRightNeighbor;
				var rrbnd = rbnd1.edgeListRightNeighbor;
				var bottomSite = leftRegion(lbnd1);
				var topSite = rightRegion(rbnd1);
				this._triangles.push(new com_nodename_delaunay_Triangle(bottomSite,topSite,rightRegion(lbnd1)));
				var v = lbnd1.vertex;
				v.vertexIndex = com_nodename_delaunay_Vertex._nvertices++;
				lbnd1.edge.setVertex(lbnd1.leftRight,v);
				rbnd1.edge.setVertex(rbnd1.leftRight,v);
				edgeList.remove(lbnd1);
				heap.remove(rbnd1);
				edgeList.remove(rbnd1);
				var leftRight = com_nodename_delaunay_LR.LEFT;
				if(bottomSite.coord.y > topSite.coord.y) {
					var tempSite = bottomSite;
					bottomSite = topSite;
					topSite = tempSite;
					leftRight = com_nodename_delaunay_LR.RIGHT;
				}
				var edge3 = com_nodename_delaunay_Edge.createBisectingEdge(bottomSite,topSite);
				this._edges.push(edge3);
				var bisector1 = com_nodename_delaunay_Halfedge.create(edge3,leftRight);
				halfEdges.push(bisector1);
				edgeList.insert(llbnd,bisector1);
				edge3.setVertex(com_nodename_delaunay_LR.other(leftRight),v);
				var vertex2 = com_nodename_delaunay_Vertex.intersect(llbnd,bisector1);
				if(vertex2 != null) {
					heap.remove(llbnd);
					vertices.push(vertex2);
					llbnd.vertex = vertex2;
					llbnd.ystar = vertex2.coord.y + bottomSite.dist(vertex2);
					heap.insert(llbnd);
				}
				vertex2 = com_nodename_delaunay_Vertex.intersect(bisector1,rrbnd);
				if(vertex2 != null) {
					vertices.push(vertex2);
					bisector1.vertex = vertex2;
					bisector1.ystar = vertex2.coord.y + bottomSite.dist(vertex2);
					heap.insert(bisector1);
				}
			} else {
				break;
			}
		}
		heap.dispose();
		edgeList.dispose();
		var _g = 0;
		while(_g < halfEdges.length) {
			var halfEdge = halfEdges[_g];
			++_g;
			halfEdge.reallyDispose();
		}
		halfEdges.length = 0;
		var _g1 = 0;
		var _g11 = this._edges;
		while(_g1 < _g11.length) {
			var edge4 = _g11[_g1];
			++_g1;
			edge4.clipVertices(this._plotBounds);
		}
		var _g2 = 0;
		while(_g2 < vertices.length) {
			var vertex3 = vertices[_g2];
			++_g2;
			vertex3.dispose();
		}
		vertices.length = 0;
	}
};
var com_nodename_geom_Point = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
com_nodename_geom_Point.__name__ = true;
var com_nodename_geom_Polygon = function(vertices) {
	this._vertices = vertices;
};
com_nodename_geom_Polygon.__name__ = true;
com_nodename_geom_Polygon.prototype = {
	winding: function() {
		var signedDoubleArea = this.signedDoubleArea();
		if(signedDoubleArea < 0) {
			return com_nodename_geom_Winding.CLOCKWISE;
		} else if(signedDoubleArea > 0) {
			return com_nodename_geom_Winding.COUNTERCLOCKWISE;
		} else {
			return com_nodename_geom_Winding.NONE;
		}
	}
	,signedDoubleArea: function() {
		var nextIndex;
		var n = this._vertices.length;
		var point;
		var next;
		var signedDoubleArea = 0.0;
		var _g1 = 0;
		while(_g1 < n) {
			var index = _g1++;
			nextIndex = (index + 1) % n;
			point = this._vertices[index];
			next = this._vertices[nextIndex];
			signedDoubleArea += point.x * next.y - next.x * point.y;
		}
		return signedDoubleArea;
	}
};
var com_nodename_geom_Rectangle = function(x,y,w,h) {
	if(h == null) {
		h = 0;
	}
	if(w == null) {
		w = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.width = w;
	this.height = h;
};
com_nodename_geom_Rectangle.__name__ = true;
var com_nodename_geom_Winding = { __ename__ : true, __constructs__ : ["CLOCKWISE","COUNTERCLOCKWISE","NONE"] };
com_nodename_geom_Winding.CLOCKWISE = ["CLOCKWISE",0];
com_nodename_geom_Winding.CLOCKWISE.toString = $estr;
com_nodename_geom_Winding.CLOCKWISE.__enum__ = com_nodename_geom_Winding;
com_nodename_geom_Winding.COUNTERCLOCKWISE = ["COUNTERCLOCKWISE",1];
com_nodename_geom_Winding.COUNTERCLOCKWISE.toString = $estr;
com_nodename_geom_Winding.COUNTERCLOCKWISE.__enum__ = com_nodename_geom_Winding;
com_nodename_geom_Winding.NONE = ["NONE",2];
com_nodename_geom_Winding.NONE.toString = $estr;
com_nodename_geom_Winding.NONE.__enum__ = com_nodename_geom_Winding;
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0?",":"") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
com_nodename_delaunay_Edge._pool = [];
com_nodename_delaunay_Edge._nedges = 0;
com_nodename_delaunay_Edge.DELETED = new com_nodename_delaunay_Edge();
com_nodename_delaunay_Halfedge._pool = [];
com_nodename_delaunay_LR.LEFT = new com_nodename_delaunay_LR("left");
com_nodename_delaunay_LR.RIGHT = new com_nodename_delaunay_LR("right");
com_nodename_delaunay_Site._pool = [];
com_nodename_delaunay_Site.EPSILON = .005;
com_nodename_delaunay_BoundsCheck.TOP = 1;
com_nodename_delaunay_BoundsCheck.BOTTOM = 2;
com_nodename_delaunay_BoundsCheck.LEFT = 4;
com_nodename_delaunay_BoundsCheck.RIGHT = 8;
com_nodename_delaunay_Vertex.VERTEX_AT_INFINITY = new com_nodename_delaunay_Vertex(NaN,NaN);
com_nodename_delaunay_Vertex._pool = [];
com_nodename_delaunay_Vertex._nvertices = 0;
haxe_ds_ObjectMap.count = 0;
DemoJs.main();
})();
